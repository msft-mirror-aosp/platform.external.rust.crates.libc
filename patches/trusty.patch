diff --git b/src/lib.rs a/src/lib.rs
index 62748d279..4d8822ec2 100644
--- b/src/lib.rs
+++ a/src/lib.rs
@@ -145,6 +145,12 @@ cfg_if! {
 
         mod teeos;
         pub use teeos::*;
+    } else if #[cfg(target_os = "trusty")] {
+        mod fixed_width_ints;
+        pub use fixed_width_ints::*;
+
+        mod trusty;
+        pub use trusty::*;
     } else if #[cfg(all(target_env = "sgx", target_vendor = "fortanix"))] {
         mod fixed_width_ints;
         pub use fixed_width_ints::*;
diff --git b/src/trusty.rs a/src/trusty.rs
new file mode 100644
index 000000000..140fa6dfe
--- /dev/null
+++ a/src/trusty.rs
@@ -0,0 +1,85 @@
+extern crate trusty_sys;
+
+pub use core::ffi::c_void;
+
+pub const PROT_READ: i32 = self::trusty_sys::MMAP_FLAG_PROT_READ as i32;
+pub const PROT_WRITE: i32 = self::trusty_sys::MMAP_FLAG_PROT_WRITE as i32;
+
+pub type size_t = usize;
+pub type ssize_t = isize;
+
+pub type off_t = i64;
+
+#[cfg(any(target_arch = "aarch64", target_arch = "arm"))]
+pub type c_char = u8;
+#[cfg(target_arch = "x86_64")]
+pub type c_char = i8;
+
+pub type c_schar = i8;
+pub type c_uchar = u8;
+pub type c_short = i16;
+pub type c_ushort = u16;
+pub type c_int = i32;
+pub type c_uint = u32;
+
+#[cfg(target_pointer_width = "32")]
+pub type c_long = i32;
+#[cfg(target_pointer_width = "64")]
+pub type c_long = i64;
+
+#[cfg(target_pointer_width = "32")]
+pub type c_ulong = u32;
+#[cfg(target_pointer_width = "64")]
+pub type c_ulong = u64;
+
+pub type c_longlong = i64;
+pub type c_ulonglong = u64;
+
+pub type c_uint8_t = u8;
+pub type c_uint16_t = u16;
+pub type c_uint32_t = u32;
+pub type c_uint64_t = u64;
+
+pub type c_int8_t = i8;
+pub type c_int16_t = i16;
+pub type c_int32_t = i32;
+pub type c_int64_t = i64;
+
+pub type time_t = c_long;
+
+pub const STDOUT_FILENO: ::c_int = 1;
+pub const STDERR_FILENO: ::c_int = 2;
+
+pub const AT_PAGESZ: ::c_ulong = 6;
+
+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;
+
+extern "C" {
+    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;
+    pub fn malloc(size: size_t) -> *mut c_void;
+    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;
+    pub fn free(p: *mut c_void);
+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;
+    pub fn posix_memalign(memptr: *mut *mut ::c_void, align: ::size_t, size: ::size_t) -> ::c_int;
+    pub fn write(fd: ::c_int, buf: *const ::c_void, count: ::size_t) -> ::ssize_t;
+    pub fn writev(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int) -> ::ssize_t;
+    pub fn close(fd: ::c_int) -> ::c_int;
+    pub fn strlen(cs: *const c_char) -> size_t;
+    pub fn getauxval(type_: c_ulong) -> c_ulong;
+    pub fn mmap(
+        addr: *mut ::c_void,
+        len: ::size_t,
+        prot: ::c_int,
+        flags: ::c_int,
+        fd: ::c_int,
+        offset: off_t,
+    ) -> *mut ::c_void;
+    pub fn munmap(addr: *mut ::c_void, len: ::size_t) -> ::c_int;
+}
+
+s! {
+    pub struct iovec {
+        pub iov_base: *mut ::c_void,
+        pub iov_len: ::size_t,
+    }
+}
